"""
GitHub Agent Manager

Manages agent sessions for GitHub PR/Issue contexts.
Creates and coordinates both conversational Agent and CollaborativeOrchestrator for GitHub events.
"""

import os
import time
import logging
from typing import Dict, Any, Optional

from agents.agent import Agent
from agents.collaborative.orchestrator import CollaborativeOrchestrator
from github_mcp.server import create_github_mcp_config
from netlify_mcp.server import create_netlify_mcp_config
from github_bot.client import get_github_client
from github_bot.utils import format_github_comment

logger = logging.getLogger(__name__)


class InMemorySessionManager:
    """
    Simple in-memory session manager for GitHub agents.

    Unlike WhatsApp which uses Redis, GitHub sessions are ephemeral
    and stored in memory within the GitHubAgentManager.
    """

    def __init__(self):
        """Initialize in-memory storage for conversation history."""
        self.conversations = {}

    def add_message(self, session_key: str, role: str, content: str):
        """
        Add a message to conversation history.

        Args:
            session_key: GitHub session key (repo#issue)
            role: Message role ("user" or "assistant")
            content: Message content
        """
        if session_key not in self.conversations:
            self.conversations[session_key] = []

        self.conversations[session_key].append({
            "role": role,
            "content": content
        })

    def get_conversation_history(self, session_key: str, max_messages: int = 10):
        """
        Get conversation history for a session.

        Args:
            session_key: GitHub session key (repo#issue)
            max_messages: Maximum number of messages to return

        Returns:
            List of message dicts with role and content
        """
        history = self.conversations.get(session_key, [])
        # Return last N messages
        return history[-max_messages:] if len(history) > max_messages else history

    def clear_conversation(self, session_key: str):
        """
        Clear conversation history for a session.

        Args:
            session_key: GitHub session key (repo#issue)
        """
        if session_key in self.conversations:
            del self.conversations[session_key]


class GitHubAgentManager:
    """
    Manages agent sessions for GitHub contexts.

    Each PR or Issue gets its own session with a dedicated orchestrator.
    Handles GitHub-specific configuration and comment posting.
    """

    # Class-level session store (shared across all instances)
    _sessions: Dict[str, Dict[str, Any]] = {}

    # Class-level session manager for conversational agents
    _session_manager: Optional[InMemorySessionManager] = None

    def __init__(self, session_key: str, context: Dict[str, Any]):
        """
        Initialize GitHub Agent Manager.

        Args:
            session_key: Unique key for this PR/Issue (e.g., "owner/repo#42")
            context: Full context from GitHub event parser
        """
        self.session_key = session_key
        self.context = context
        self.github_client = get_github_client()

        # Initialize class-level session manager if not already created
        if GitHubAgentManager._session_manager is None:
            GitHubAgentManager._session_manager = InMemorySessionManager()

        logger.info(f"GitHubAgentManager initialized for {session_key}")

    async def process_command(self, command: str):
        """
        Process a @droid command.

        Checks if there's an existing session (multi-turn conversation)
        or creates a new one.

        Args:
            command: The command text extracted from @droid mention
        """
        # Add ðŸ‘€ reaction to acknowledge the mention
        await self._add_eyes_reaction()

        session = self._sessions.get(self.session_key)

        if session and session.get("status") == "in_progress":
            # Existing session - this is a follow-up/refinement
            logger.info(f"Continuing existing session for {self.session_key}")
            orchestrator = session["orchestrator"]

            # Handle as refinement (no intermediate messages)
            result = await orchestrator.handle_refinement(command)

            # Send only the final result
            await self._send_notification(
                format_github_comment(
                    f"âœ… Refinement applied!\n\n{result if isinstance(result, str) else ''}",
                    status="check"
                )
            )

        else:
            # New session - check if this is a webapp request or just conversation
            logger.info(f"Starting new session for {self.session_key}")

            # Check if this is actually a webapp build request
            is_webapp = await self._is_webapp_request(command)

            if not is_webapp:
                # Regular conversation - use conversational agent
                logger.info(f"Routing to conversational agent for {self.session_key}")

                # Get or create conversational agent for this session
                agent = await self._get_or_create_agent()

                # Process message with agent
                response = await agent.process_message(command)

                # Send agent's response
                await self._send_notification(
                    format_github_comment(response, status="check")
                )
                return

            # Create orchestrator for webapp request
            logger.info(f"Routing to orchestrator for webapp work: {self.session_key}")
            orchestrator = await self._create_orchestrator()

            # Store session
            self._sessions[self.session_key] = {
                "orchestrator": orchestrator,
                "context": self.context,
                "status": "in_progress",
                "started_at": time.time(),
                "command": command
            }

            # Execute workflow (silent mode - no intermediate notifications)
            result = await orchestrator.build_webapp(command)

            # Send only the final result
            await self._send_notification(
                format_github_comment(result, status="check")
            )

            # Mark session as completed
            self._sessions[self.session_key]["status"] = "completed"
            self._sessions[self.session_key]["completed_at"] = time.time()

    def _get_mcp_servers_config(self) -> Dict[str, Any]:
        """
        Get MCP server configuration for GitHub context.

        Returns:
            Dictionary of available MCP servers
        """
        # Get GitHub MCP config
        github_token = os.getenv("GITHUB_PERSONAL_ACCESS_TOKEN")
        repo = self.context["repository"]["full_name"]

        # Configure GitHub MCP with repository context
        github_mcp_config = create_github_mcp_config(token=github_token)

        # Set repository in environment for MCP
        github_mcp_config["env"] = {
            **github_mcp_config.get("env", {}),
            "GITHUB_REPOSITORY": repo
        }

        # Get Netlify MCP config if enabled
        available_mcp_servers = {"github": github_mcp_config}

        if os.getenv("ENABLE_NETLIFY_MCP", "false").lower() == "true":
            netlify_token = os.getenv("NETLIFY_PERSONAL_ACCESS_TOKEN")
            if netlify_token:
                netlify_mcp_config = create_netlify_mcp_config(token=netlify_token)
                available_mcp_servers["netlify"] = netlify_mcp_config

        return available_mcp_servers

    async def _get_or_create_agent(self) -> Agent:
        """
        Get or create a conversational Agent for this GitHub session.

        Returns:
            Agent instance for conversation
        """
        # Check if agent already exists in session
        session = self._sessions.get(self.session_key)
        if session and "agent" in session:
            return session["agent"]

        # Create new agent
        available_mcp_servers = self._get_mcp_servers_config()

        agent = Agent(
            phone_number=self.session_key,  # Use session_key as identifier
            session_manager=self._session_manager,  # Use class-level session manager
            available_mcp_servers=available_mcp_servers
        )

        # Store agent in session for reuse
        if not session:
            self._sessions[self.session_key] = {"agent": agent}
        else:
            session["agent"] = agent

        logger.info(
            f"Created conversational agent for {self.session_key} with "
            f"MCP servers: {list(available_mcp_servers.keys())}"
        )

        return agent

    async def _silent_callback(self, message: str):
        """
        Silent callback for orchestrator - logs but doesn't send notifications.

        This prevents intermediate status updates from being posted to GitHub.
        Only the final result will be sent.

        Args:
            message: Message from orchestrator (logged but not sent)
        """
        logger.debug(f"[SILENT] Orchestrator message: {message[:100]}...")

    async def _create_orchestrator(self) -> CollaborativeOrchestrator:
        """
        Create a new CollaborativeOrchestrator configured for GitHub.

        Returns:
            Configured orchestrator instance
        """
        available_mcp_servers = self._get_mcp_servers_config()

        # Create orchestrator with silent callback (no intermediate notifications)
        orchestrator = CollaborativeOrchestrator(
            user_id=self.session_key,
            send_message_callback=self._silent_callback,  # Silent mode
            platform="github",
            github_context=self.context,
            available_mcp_servers=available_mcp_servers
        )

        logger.info(
            f"Created orchestrator for {self.session_key} with "
            f"MCP servers: {list(available_mcp_servers.keys())}"
        )

        return orchestrator

    async def _add_eyes_reaction(self):
        """
        Add ðŸ‘€ reaction to the comment that mentioned the bot.

        This acknowledges the mention immediately while the bot processes.
        """
        try:
            comment_id = self.context.get("comment", {}).get("id")
            if not comment_id:
                logger.warning("Cannot add reaction: no comment ID found")
                return

            repo = self.context["repository"]["full_name"]

            # Add ðŸ‘€ (eyes) reaction
            result = self.github_client.react_to_comment(
                repo=repo,
                comment_id=comment_id,
                reaction="eyes"
            )

            if result:
                logger.info(f"Added ðŸ‘€ reaction to comment {comment_id}")
            else:
                logger.warning(f"Failed to add reaction to comment {comment_id}")

        except Exception as e:
            logger.error(f"Error adding reaction: {e}", exc_info=True)

    async def _send_notification(self, message: str):
        """
        Send a notification to GitHub as a comment.

        This is the callback used by the orchestrator to post status updates.

        Args:
            message: Message to post (supports markdown)
        """
        try:
            repo = self.context["repository"]["full_name"]
            number = self._get_issue_number()

            if not number:
                logger.error("Cannot post comment: no issue/PR number found")
                return

            # Post comment
            result = self.github_client.post_comment(
                repo=repo,
                issue_number=number,
                body=message
            )

            if result:
                logger.info(f"Posted notification to {repo}#{number}")
            else:
                logger.warning(f"Failed to post notification to {repo}#{number}")

        except Exception as e:
            logger.error(f"Error posting notification: {e}", exc_info=True)

    def _get_issue_number(self) -> Optional[int]:
        """
        Get the issue or PR number from context.

        Returns:
            Issue/PR number, or None if not found
        """
        if self.context.get("type") == "pull_request":
            return self.context.get("pull_request", {}).get("number")
        else:
            return self.context.get("issue", {}).get("number")

    async def _is_webapp_request(self, message: str) -> bool:
        """
        Use AI to intelligently detect if user is requesting webapp creation/work

        Args:
            message: User's message text

        Returns:
            True if message appears to be a webapp build/fix request
        """
        # Quick heuristic for obvious cases to save API calls
        quick_check_keywords = ["build", "create", "make", "fix", "deploy", "webapp", "website", "application", "app"]
        message_lower = message.lower()

        if any(keyword in message_lower for keyword in quick_check_keywords):
            # Likely a webapp request
            pass
        elif len(message.split()) <= 3:
            # Very short messages like "hello", "hi", "thanks" are unlikely to be webapp requests
            return False

        # Use AI to determine intent
        decision_prompt = f"""Analyze this user message and determine if they are requesting webapp/website work or just having a conversation.

**User Message:** "{message}"

**Your Task:**
Determine if this is:
A) A request to build/create/design/fix/deploy a webapp, website, or application
B) A regular conversation, question, greeting, or general request

**Examples of webapp requests:**
- "Build me a todo list app"
- "Create a booking website"
- "Fix the login bug"
- "Deploy this to Netlify"
- "Make a dashboard"

**Examples of regular conversation:**
- "How are you?"
- "Hello"
- "What can you do?"
- "Thanks"
- "hi"

**Output Format (JSON):**
{{
  "is_webapp_request": true | false,
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation"
}}

Be precise. Only return true if the user is clearly requesting webapp/website development work."""

        try:
            # Create a temporary Claude SDK for decision making
            import sys
            import os
            sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
            from sdk.claude_sdk import ClaudeSDK

            decision_sdk = ClaudeSDK(available_mcp_servers={})
            response = await decision_sdk.send_message(decision_prompt)
            await decision_sdk.close()

            # Extract JSON
            import json
            import re

            json_match = re.search(r'```(?:json)?\s*(\{.*?\})\s*```', response, re.DOTALL)
            if json_match:
                decision = json.loads(json_match.group(1))
            elif response.strip().startswith('{'):
                decision = json.loads(response)
            else:
                # Fallback: if AI didn't return JSON, assume not webapp request
                logger.warning("Could not parse webapp detection response, defaulting to False")
                return False

            is_webapp = decision.get('is_webapp_request', False)
            confidence = decision.get('confidence', 0.0)
            reasoning = decision.get('reasoning', 'N/A')

            logger.info(f"Webapp detection: {is_webapp} (confidence: {confidence:.2f}) - {reasoning}")

            return is_webapp

        except Exception as e:
            logger.error(f"Error in webapp detection: {e}")
            # Fallback to keyword matching only on error
            webapp_keywords = ["build", "create", "make", "fix", "deploy", "website", "webapp", "app", "site"]
            return any(keyword in message_lower for keyword in webapp_keywords)

    @classmethod
    def get_active_sessions(cls) -> Dict[str, Dict[str, Any]]:
        """
        Get all active sessions.

        Returns:
            Dict of session_key -> session data
        """
        return {
            key: value
            for key, value in cls._sessions.items()
            if value.get("status") == "in_progress"
        }

    @classmethod
    def cleanup_old_sessions(cls, max_age_hours: int = 24):
        """
        Clean up sessions older than max_age_hours.

        Args:
            max_age_hours: Maximum age in hours before cleanup
        """
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600

        keys_to_remove = []
        for key, session in cls._sessions.items():
            started_at = session.get("started_at", current_time)
            age = current_time - started_at

            if age > max_age_seconds:
                keys_to_remove.append(key)

        for key in keys_to_remove:
            logger.info(f"Cleaning up old session: {key}")
            del cls._sessions[key]

        if keys_to_remove:
            logger.info(f"Cleaned up {len(keys_to_remove)} old sessions")

    @classmethod
    def get_session_stats(cls) -> Dict[str, Any]:
        """
        Get statistics about current sessions.

        Returns:
            Dict with session statistics
        """
        total = len(cls._sessions)
        in_progress = sum(
            1 for s in cls._sessions.values()
            if s.get("status") == "in_progress"
        )
        completed = sum(
            1 for s in cls._sessions.values()
            if s.get("status") == "completed"
        )

        return {
            "total_sessions": total,
            "in_progress": in_progress,
            "completed": completed,
            "session_keys": list(cls._sessions.keys())
        }
